// src/vue.ts
import { compileScript, parse } from "@vue/compiler-sfc";
var parseSFC = (code, id) => {
  var _a;
  const { descriptor } = parse(code, {
    filename: id
  });
  const lang = (_a = descriptor.script || descriptor.scriptSetup) == null ? void 0 : _a.lang;
  let scriptCompiled;
  return {
    ...descriptor,
    lang,
    get scriptCompiled() {
      if (scriptCompiled)
        return scriptCompiled;
      return scriptCompiled = compileScript(descriptor, {
        id
      });
    }
  };
};
var addNormalScript = ({ script, lang }, s) => {
  return {
    start() {
      if (script)
        return script.loc.end.offset;
      const attrs = lang ? ` lang="${lang}"` : "";
      s.prependLeft(0, `<script${attrs}>`);
      return 0;
    },
    end() {
      if (!script)
        s.appendRight(0, `
<\/script>
`);
    }
  };
};

// src/ast.ts
import path from "path";
import { babelParse as _babelParse, walkIdentifiers } from "@vue/compiler-sfc";

// src/constants.ts
var DEFINE_PROPS = "defineProps";
var DEFINE_EMITS = "defineEmits";
var DEFINE_OPTIONS = "defineOptions";
var DEFINE_MODEL = "defineModel";
var DEFINE_SETUP_COMPONENT = "defineSetupComponent";
var DEFINE_RENDER = "defineRender";
var REPO_ISSUE_URL = "https://github.com/sxzz/unplugin-vue-macros/issues";
var MAGIC_COMMENT_STATIC = "hoist-static";
var REGEX_SRC_FILE = /\.[cm]?[jt]sx?$/;
var REGEX_TS_FILE = /^[cm]?tsx?$/;
var REGEX_JSX_FILE = /^[cm]?[jt]sx$/;
var REGEX_SETUP_SFC = /\.setup\.[cm]?[jt]sx?$/;
var REGEX_VUE_SFC = /\.vue$/;

// src/ast.ts
function getLang(filename) {
  return path.extname(filename).replace(/^\./, "");
}
function isTs(lang) {
  return lang && REGEX_TS_FILE.test(lang);
}
function babelParse(code, lang) {
  const plugins = [];
  if (lang) {
    if (isTs(lang))
      plugins.push("typescript");
    if (REGEX_JSX_FILE.test(lang))
      plugins.push("jsx");
  }
  const { program } = _babelParse(code, {
    sourceType: "module",
    plugins
  });
  return program;
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, setupBindings) {
  if (!node)
    return;
  walkIdentifiers(node, (id) => {
    if (setupBindings.includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables (${id.name}) because it will be hoisted outside of the setup() function.`
      );
  });
}
function isStaticExpression(node) {
  var _a;
  if ((_a = node.leadingComments) == null ? void 0 : _a.some(
    (comment) => comment.value.trim() === MAGIC_COMMENT_STATIC
  ))
    return true;
  switch (node.type) {
    case "UnaryExpression":
      return isStaticExpression(node.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticExpression(node.left) && isStaticExpression(node.right);
    case "ConditionalExpression":
      return isStaticExpression(node.test) && isStaticExpression(node.consequent) && isStaticExpression(node.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticExpression(expr));
    case "ParenthesizedExpression":
    case "TSNonNullExpression":
    case "TSAsExpression":
    case "TSTypeAssertion":
      return isStaticExpression(node.expression);
  }
  if (isLiteralType(node))
    return true;
  return false;
}
function isLiteralType(node) {
  return node.type.endsWith("Literal");
}
function getStaticKey(node, computed = false, raw = true) {
  switch (node.type) {
    case "StringLiteral":
    case "NumericLiteral":
      return raw ? node.extra.raw : node.value;
    case "Identifier":
      if (!computed)
        return raw ? `'${node.name}'` : node.name;
    default:
      throw new SyntaxError(`Unexpected node type: ${node.type}`);
  }
}

// src/magic-string.ts
import MagicStringBase from "magic-string";
var MagicString = class extends MagicStringBase {
  removeNode(node, { offset = 0 } = {}) {
    this.remove(offset + node.start, offset + node.end);
    return this;
  }
  moveNode(node, index, { offset = 0 } = {}) {
    this.move(offset + node.start, offset + node.end, index);
    return this;
  }
  sliceNode(node, { offset = 0 } = {}) {
    return this.slice(offset + node.start, offset + node.end);
  }
  sliceNodes(nodes, { offset = 0 } = {}) {
    return this.slice(
      offset + nodes[0].start,
      offset + nodes.slice(-1)[0].end
    );
  }
  overwriteNode(node, content, { offset = 0, ...options } = {}) {
    const _content = typeof content === "string" ? content : this.sliceNode(content);
    this.overwrite(offset + node.start, offset + node.end, _content, options);
    return this;
  }
};

// src/unplugin.ts
var getTransformResult = (s, id) => {
  if (s == null ? void 0 : s.hasChanged()) {
    return {
      code: s.toString(),
      get map() {
        return s.generateMap({
          source: id,
          includeContent: true,
          hires: true
        });
      }
    };
  }
};
export {
  DEFINE_EMITS,
  DEFINE_MODEL,
  DEFINE_OPTIONS,
  DEFINE_PROPS,
  DEFINE_RENDER,
  DEFINE_SETUP_COMPONENT,
  MAGIC_COMMENT_STATIC,
  MagicString,
  REGEX_JSX_FILE,
  REGEX_SETUP_SFC,
  REGEX_SRC_FILE,
  REGEX_TS_FILE,
  REGEX_VUE_SFC,
  REPO_ISSUE_URL,
  addNormalScript,
  babelParse,
  checkInvalidScopeReference,
  getLang,
  getStaticKey,
  getTransformResult,
  isCallOf,
  isLiteralType,
  isStaticExpression,
  isTs,
  parseSFC
};
